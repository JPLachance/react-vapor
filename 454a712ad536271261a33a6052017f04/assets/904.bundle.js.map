{"version":3,"sources":["webpack:///./src/hoc/withEditing/tests/withEditing.spec.tsx"],"names":[],"mappings":"6FAAA,OAAe","file":"assets/904.bundle.js","sourcesContent":["export default \"import {mount} from 'enzyme';\\r\\nimport * as React from 'react';\\r\\nimport {Provider} from 'react-redux';\\r\\nimport {Store} from 'redux';\\r\\n\\r\\nimport {Button} from '../../../components/button/Button';\\r\\nimport {Input} from '../../../components/input/Input';\\r\\nimport {StickyFooter} from '../../../components/stickyFooter/StickyFooter';\\r\\nimport {IReactVaporState} from '../../../ReactVapor';\\r\\nimport {clearState} from '../../../utils/ReduxUtils';\\r\\nimport {TestUtils} from '../../../utils/tests/TestUtils';\\r\\nimport {IWithDirtyProps} from '../../withDirty/withDirty';\\r\\nimport {IWithEditing, withEditing} from '../withEditing';\\r\\n\\r\\ndescribe('Component with editing', () => {\\r\\n    let store: Store<IReactVaporState>;\\r\\n\\r\\n    beforeEach(() => {\\r\\n        store = TestUtils.buildStore();\\r\\n    });\\r\\n\\r\\n    afterEach(() => {\\r\\n        store.dispatch(clearState());\\r\\n    });\\r\\n\\r\\n    class SomeInput extends React.Component<IWithDirtyProps> {\\r\\n        static ID = 'SomeInput';\\r\\n\\r\\n        render() {\\r\\n            return <Input onChange={() => this.props.toggleIsDirty(true)} />;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    const mountComponentWithProps = (config: IWithEditing = {id: SomeInput.ID}) => {\\r\\n        const SomeInputWithEditingHOC = withEditing(config)(SomeInput);\\r\\n        return mount(\\r\\n            <Provider store={store}>\\r\\n                <SomeInputWithEditingHOC />\\r\\n            </Provider>\\r\\n        );\\r\\n    };\\r\\n\\r\\n    it('should mount without error', () => {\\r\\n        expect(() => mountComponentWithProps()).not.toThrow();\\r\\n    });\\r\\n\\r\\n    it('should not set the component as dirty if isDirty is not set to true in the config', () => {\\r\\n        mountComponentWithProps();\\r\\n        expect(store.getState().dirtyComponents).toEqual([]);\\r\\n    });\\r\\n\\r\\n    it('should set the component as dirty if isDirty is set to true in the config', () => {\\r\\n        mountComponentWithProps({id: SomeInput.ID, isDirty: true});\\r\\n        expect(store.getState().dirtyComponents).toEqual([SomeInput.ID]);\\r\\n    });\\r\\n\\r\\n    it('should remove the component as dirty in the state on unmount', () => {\\r\\n        const component = mountComponentWithProps({id: SomeInput.ID, isDirty: true});\\r\\n        expect(store.getState().dirtyComponents).toEqual([SomeInput.ID]);\\r\\n        component.unmount();\\r\\n        expect(store.getState().dirtyComponents).toEqual([]);\\r\\n    });\\r\\n\\r\\n    it('should not render a sticky footer if no footer children are passed', () => {\\r\\n        expect(mountComponentWithProps().find(StickyFooter).length).toBe(0);\\r\\n    });\\r\\n\\r\\n    it('should render a sticky footer if footerChildren are passed', () => {\\r\\n        const footerChildren = <Button />;\\r\\n        expect(mountComponentWithProps({id: SomeInput.ID, footerChildren}).find(StickyFooter).length).toBe(1);\\r\\n    });\\r\\n});\\r\\n\""],"sourceRoot":""}