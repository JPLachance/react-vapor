(window.webpackJsonp=window.webpackJsonp||[]).push([[140],{1243:function(r,e,t){"use strict";t.r(e),e.default="import {mount, ReactWrapper} from 'enzyme';\r\nimport {shallowWithStore} from 'enzyme-redux';\r\nimport * as React from 'react';\r\nimport {Provider} from 'react-redux';\r\nimport {Store} from 'redux';\r\nimport * as _ from 'underscore';\r\n\r\nimport {IReactVaporState} from '../../../ReactVapor';\r\nimport {clearState} from '../../../utils/ReduxUtils';\r\nimport {getStoreMock, ReactVaporMockStore, TestUtils} from '../../../utils/tests/TestUtils';\r\nimport {IInlinePromptOptions} from '../../inlinePrompt/InlinePrompt';\r\nimport {addPrompt, removePrompt} from '../../inlinePrompt/InlinePromptActions';\r\nimport {IActionOptions} from '../Action';\r\nimport {ActionBar, ActionBarConnected, IActionBarProps} from '../ActionBar';\r\nimport {addActionsToActionBar, removeActionBar} from '../ActionBarActions';\r\nimport {filterItems, removeItemFilter} from '../filters/ItemFilterActions';\r\nimport {PrimaryActionConnected} from '../PrimaryActionConnected';\r\nimport {SecondaryActionsConnected} from '../SecondaryActionsConnected';\r\n\r\ndescribe('Actions', () => {\r\n    const id: string = 'secondary-actions';\r\n    const actions: IActionOptions[] = [\r\n        {\r\n            name: 'action',\r\n            link: 'http://coveo.com',\r\n            target: '_blank',\r\n            primary: true,\r\n            enabled: true,\r\n        },\r\n        {\r\n            name: 'action2',\r\n            trigger: jasmine.createSpy('triggerMethod'),\r\n            enabled: true,\r\n        },\r\n        {\r\n            name: 'action3',\r\n            trigger: jasmine.createSpy('triggerMethod'),\r\n            enabled: false,\r\n        },\r\n        {\r\n            name: 'action4',\r\n            trigger: jasmine.createSpy('triggerMethod'),\r\n            enabled: false,\r\n            hideDisabled: false,\r\n        },\r\n    ];\r\n    const itemFilter: string = 'the item';\r\n    const itemFilterLabel: string = 'Item filter';\r\n\r\n    describe('<ActionBarConnected />', () => {\r\n        let wrapper: ReactWrapper;\r\n        let actionBar: ReactWrapper<IActionBarProps & any>;\r\n        let store: Store<IReactVaporState>;\r\n\r\n        beforeEach(() => {\r\n            store = TestUtils.buildStore();\r\n\r\n            wrapper = mount(\r\n                <Provider store={store}>\r\n                    <ActionBarConnected id={id} itemFilterLabel={itemFilterLabel} />\r\n                </Provider>,\r\n                {attachTo: document.getElementById('App')}\r\n            );\r\n            store.dispatch(addActionsToActionBar(id, actions));\r\n            store.dispatch(filterItems(id, itemFilter));\r\n            wrapper.update();\r\n            actionBar = wrapper.find(ActionBar).first();\r\n        });\r\n\r\n        afterEach(() => {\r\n            store.dispatch(clearState());\r\n            wrapper.detach();\r\n        });\r\n\r\n        it('should get an id as a prop', () => {\r\n            const idProp = actionBar.props().id;\r\n\r\n            expect(idProp).toBeDefined();\r\n            expect(idProp).toBe(id);\r\n        });\r\n\r\n        it('should get the enabled actions and unhidden disabled actions as a prop', () => {\r\n            const actionsProp = actionBar.props().actions;\r\n\r\n            expect(actionsProp).toBeDefined();\r\n            expect(actionsProp.length).toBe(\r\n                actions.filter((action) => action.enabled || action.hideDisabled === false).length\r\n            );\r\n            expect(actionsProp[0]).toEqual(jasmine.objectContaining(actions[0]));\r\n        });\r\n\r\n        it('should get the item filter as a prop', () => {\r\n            const itemFilterProp = actionBar.props().itemFilter;\r\n\r\n            expect(itemFilterProp).toBeDefined();\r\n            expect(itemFilterProp).toBe(itemFilter);\r\n        });\r\n\r\n        it('should get isLoading as a prop', () => {\r\n            expect(actionBar.props().isLoading).toBeDefined();\r\n        });\r\n\r\n        it('should get what to do on render as a prop', () => {\r\n            const onRenderProp = actionBar.props().onRender;\r\n\r\n            expect(onRenderProp).toBeDefined();\r\n        });\r\n\r\n        it('should what to do on destroy as a prop', () => {\r\n            const onDestroyProp = actionBar.props().onDestroy;\r\n\r\n            expect(onDestroyProp).toBeDefined();\r\n        });\r\n\r\n        it('should get what to do on clearItemFilter as a prop', () => {\r\n            const clearItemFilterProp = actionBar.props().clearItemFilter;\r\n\r\n            expect(clearItemFilterProp).toBeDefined();\r\n        });\r\n\r\n        it('should get withReduxState as a prop', () => {\r\n            const withReduxStateProp = actionBar.props().withReduxState;\r\n\r\n            expect(withReduxStateProp).toBeDefined();\r\n            expect(withReduxStateProp).toBe(true);\r\n        });\r\n\r\n        it('should call onRender prop when mounted', () => {\r\n            wrapper.unmount();\r\n            store.dispatch(clearState());\r\n            expect(store.getState().actionBars.length).toBe(0);\r\n            expect(store.getState().itemFilters.length).toBe(0);\r\n\r\n            wrapper.mount();\r\n            expect(store.getState().actionBars.length).toBe(1);\r\n            expect(store.getState().itemFilters.length).toBe(1);\r\n        });\r\n\r\n        it('should should not add an item filter on mount if there is no item filter label sent as prop', () => {\r\n            expect(store.getState().itemFilters.length).toBe(1);\r\n\r\n            wrapper = mount(\r\n                <Provider store={store}>\r\n                    <ActionBarConnected id={id} />\r\n                </Provider>,\r\n                {attachTo: document.getElementById('App')}\r\n            );\r\n            actionBar = wrapper.find(ActionBar).first();\r\n\r\n            expect(store.getState().itemFilters.length).toBe(0);\r\n        });\r\n\r\n        it('should call onDestroy prop when will unmount', () => {\r\n            wrapper.unmount();\r\n            expect(store.getState().actionBars.length).toBe(0);\r\n        });\r\n\r\n        it('should display a <PrimaryActionConnected /> component if there is a primary action', () => {\r\n            expect(actionBar.find(PrimaryActionConnected).length).not.toBe(0);\r\n        });\r\n\r\n        it('should display a <SecondaryActionsConnected /> component if there are secondary actions', () => {\r\n            expect(actionBar.find(SecondaryActionsConnected).length).toBe(1);\r\n        });\r\n\r\n        it('should get the <InlinePrompt /> as a prop', () => {\r\n            const expectedClass = 'expected-class';\r\n            const inlinePromptOptions: IInlinePromptOptions = {\r\n                onClick: jasmine.createSpy('onClick'),\r\n                userChoice: {},\r\n                className: expectedClass,\r\n            };\r\n            store.dispatch(addPrompt(id, inlinePromptOptions));\r\n            wrapper.update();\r\n\r\n            const promptProp = wrapper.find(ActionBar).props().prompt;\r\n            expect(promptProp).toBeDefined();\r\n\r\n            expect(wrapper.find(ActionBar).find(`.prompt-${expectedClass}`).length).toBe(1);\r\n        });\r\n\r\n        it('should call onClearItemFilter when calling clearItemFilter', () => {\r\n            const onClearItemFilterSpy = jasmine.createSpy('onClearItemFilter');\r\n\r\n            wrapper = mount(\r\n                <Provider store={store}>\r\n                    <ActionBarConnected\r\n                        id={id}\r\n                        itemFilterLabel={itemFilterLabel}\r\n                        onClearItemFilter={onClearItemFilterSpy}\r\n                    />\r\n                </Provider>,\r\n                {attachTo: document.getElementById('App')}\r\n            );\r\n            actionBar = wrapper.find(ActionBar).first();\r\n\r\n            actionBar.props().clearItemFilter();\r\n\r\n            expect(onClearItemFilterSpy).toHaveBeenCalled();\r\n        });\r\n\r\n        it('should not throw on clearItemFilter if there is no onClearItemFilter prop', () => {\r\n            expect(() => {\r\n                actionBar.props().clearItemFilter();\r\n            }).not.toThrow();\r\n        });\r\n\r\n        it('should clear the item filter when calling clearItemFilter', () => {\r\n            expect(_.findWhere(store.getState().itemFilters, {id: id}).item).toBe(itemFilter);\r\n\r\n            actionBar.props().clearItemFilter();\r\n\r\n            expect(_.findWhere(store.getState().itemFilters, {id: id}).item).toBe('');\r\n        });\r\n\r\n        describe('dispatch onDestroy', () => {\r\n            let RStore: ReactVaporMockStore;\r\n            const ownProps = {\r\n                id: 'id',\r\n            };\r\n\r\n            beforeEach(() => {\r\n                RStore = getStoreMock();\r\n            });\r\n\r\n            it('should remove the prompt onDestroy', () => {\r\n                const component = shallowWithStore(<ActionBarConnected {...ownProps} />, RStore).dive();\r\n                component.unmount();\r\n\r\n                expect(RStore.getActions()).toContain(removePrompt(ownProps.id));\r\n            });\r\n\r\n            it('should remove the item filter onDestroy', () => {\r\n                const component = shallowWithStore(<ActionBarConnected {...ownProps} />, RStore).dive();\r\n                component.unmount();\r\n\r\n                expect(RStore.getActions()).toContain(removeItemFilter(ownProps.id));\r\n            });\r\n\r\n            it('should remove the action bar onDestroy', () => {\r\n                const component = shallowWithStore(<ActionBarConnected {...ownProps} />, RStore).dive();\r\n                component.unmount();\r\n\r\n                expect(RStore.getActions()).toContain(removeActionBar(ownProps.id));\r\n            });\r\n        });\r\n    });\r\n});\r\n"}}]);
//# sourceMappingURL=140.bundle.js.map