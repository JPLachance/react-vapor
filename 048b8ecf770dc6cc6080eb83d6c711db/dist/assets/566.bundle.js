(window.webpackJsonp=window.webpackJsonp||[]).push([[566],{1671:function(n,e,t){"use strict";t.r(e),e.default="import {mount, ReactWrapper, shallow} from 'enzyme';\r\n// tslint:disable-next-line:no-unused-variable\r\nimport * as React from 'react';\r\nimport {Store} from 'redux';\r\n\r\nimport {IReactVaporState} from '../../../ReactVapor';\r\nimport {TestUtils} from '../../../utils/tests/TestUtils';\r\nimport {ILabelProps} from '../../input';\r\nimport {validateInputValue} from '../../input/InputActions';\r\nimport {AddInput} from '../AddInput';\r\nimport {DeletableInput} from '../DeletableInput';\r\nimport {IMultilineInputProps, IMultilineInputValue, MultilineInput} from '../MultilineInput';\r\n\r\ndescribe('MultilineInput', () => {\r\n    describe('<MultilineInput />', () => {\r\n        it('should render without errors', () => {\r\n            expect(() => {\r\n                shallow(<MultilineInput />);\r\n            }).not.toThrow();\r\n        });\r\n    });\r\n\r\n    describe('<MultilineInput />', () => {\r\n        let store: Store<IReactVaporState>;\r\n\r\n        let multilineInput: ReactWrapper<IMultilineInputProps, any>;\r\n        const valueId = 'an-id';\r\n        const valueValue = 'a-value';\r\n        const multilineInputValue: IMultilineInputValue = {\r\n            id: valueId,\r\n            value: valueValue,\r\n        };\r\n        const aNewValue = 'a-new-value';\r\n\r\n        beforeEach(() => {\r\n            store = TestUtils.buildStore();\r\n            multilineInput = mount(<MultilineInput />, {attachTo: document.getElementById('App')});\r\n        });\r\n\r\n        afterEach(() => {\r\n            multilineInput.detach();\r\n        });\r\n\r\n        it('should render an AddInput when no values are specified', () => {\r\n            const innerAddInput = multilineInput.find('AddInput');\r\n\r\n            expect(innerAddInput.length).toBe(1);\r\n        });\r\n\r\n        it('should be able to render an invalid message if the input is not valid', () => {\r\n            store.dispatch(validateInputValue(valueId, false));\r\n\r\n            const invalidMessage = 'ðŸ“¦';\r\n            const inputLabel = shallow(<MultilineInput invalidMessage={invalidMessage} />)\r\n                .find('AddInput')\r\n                .prop('labelProps') as ILabelProps;\r\n\r\n            expect(inputLabel.invalidMessage).toBe(invalidMessage);\r\n        });\r\n\r\n        it('should render no DeletableInput when no values are specified.', () => {\r\n            const innerDeleteInput = multilineInput.find(DeletableInput);\r\n\r\n            expect(innerDeleteInput.length).toBe(0);\r\n        });\r\n\r\n        it('should render one DeletableInput when one value is specified', () => {\r\n            multilineInput.setProps({values: [multilineInputValue]});\r\n            multilineInput.mount();\r\n            const innerDeleteInput = multilineInput.find(DeletableInput);\r\n\r\n            expect(innerDeleteInput.length).toBe(1);\r\n        });\r\n\r\n        it('should call prop onChange with new value when add input changes', () => {\r\n            const changeSpy = jasmine.createSpy('onChange');\r\n            multilineInput.setProps({onChange: changeSpy, values: []});\r\n            multilineInput.mount();\r\n\r\n            const innerAddInput = multilineInput.find(AddInput);\r\n            expect(innerAddInput.length).toBe(1);\r\n\r\n            innerAddInput.props().onBlur(aNewValue);\r\n\r\n            expect(changeSpy.calls.count()).toBe(1);\r\n            expect(changeSpy.calls.first().args[0][0].value).toBe(aNewValue);\r\n        });\r\n\r\n        it('should call prop onChange with updated value when delete input changes', () => {\r\n            const changeSpy = jasmine.createSpy('onChange');\r\n            multilineInput.setProps({onChange: changeSpy, values: [multilineInputValue]});\r\n            multilineInput.mount();\r\n\r\n            const innerDeleteInput = multilineInput.find(DeletableInput);\r\n            expect(innerDeleteInput.length).toBe(1);\r\n\r\n            innerDeleteInput.props().onBlur(aNewValue);\r\n\r\n            expect(changeSpy.calls.count()).toBe(1);\r\n            expect(changeSpy.calls.first().args[0][0].value).toBe(aNewValue);\r\n        });\r\n\r\n        it('should call prop onChange with removed value when delete input changes for something empty', () => {\r\n            const changeSpy = jasmine.createSpy('onChange');\r\n            multilineInput.setProps({onChange: changeSpy, values: [multilineInputValue]});\r\n            multilineInput.mount();\r\n\r\n            const innerDeleteInput = multilineInput.find(DeletableInput);\r\n            expect(innerDeleteInput.length).toBe(1);\r\n\r\n            innerDeleteInput.props().onBlur('');\r\n\r\n            expect(changeSpy.calls.count()).toBe(1);\r\n            expect(changeSpy.calls.first().args[0].length).toBe(0);\r\n        });\r\n    });\r\n});\r\n"}}]);
//# sourceMappingURL=566.bundle.js.map