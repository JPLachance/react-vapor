(window.webpackJsonp=window.webpackJsonp||[]).push([[936],{2032:function(n,t,e){"use strict";e.r(t),t.default="import {ValidationSelectors} from '../ValidationSelectors';\nimport {ValidationState} from '../ValidationState';\n\ndescribe('ValidationSelectors', () => {\n    const existingComponentId = 'ü•ù';\n\n    const getValidationState = (validation: Partial<ValidationState>) =>\n        ({\n            isDirty: [],\n            error: [],\n            warning: [],\n            ...validation,\n        } as ValidationState);\n    const getStateForExistingComponent = (validation: Partial<ValidationState>) => ({\n        validation: {\n            [existingComponentId]: getValidationState(validation),\n        },\n    });\n\n    describe('getErrors', () => {\n        it('should return an empty array if the state is empty', () => {\n            const errors = ValidationSelectors.getErrors(existingComponentId)({\n                validation: {},\n            });\n\n            expect(errors.length).toBe(0);\n        });\n\n        it('should return the error for the given component', () => {\n            const subId = 'something';\n            const errorValue = 'üî¥';\n            const result = ValidationSelectors.getErrors(existingComponentId)(\n                getStateForExistingComponent({\n                    error: [\n                        {\n                            subId,\n                            value: errorValue,\n                        },\n                    ],\n                })\n            );\n\n            expect(result.length).toBe(1);\n            expect(result[0]).toEqual({\n                subId,\n                value: errorValue,\n            });\n        });\n\n        it('should not return errors that have been cleared for the given component', () => {\n            const subId = 'something';\n            const result = ValidationSelectors.getErrors(existingComponentId)(\n                getStateForExistingComponent({\n                    error: [\n                        {\n                            subId,\n                            value: '',\n                        },\n                    ],\n                })\n            );\n\n            expect(result.length).toBe(0);\n        });\n    });\n\n    describe('getWarnings', () => {\n        it('should return an empty array if the state is empty', () => {\n            const result = ValidationSelectors.getWarnings(existingComponentId)({\n                validation: {},\n            });\n\n            expect(result.length).toBe(0);\n        });\n\n        it('should return the warning', () => {\n            const subId = 'something';\n            const warningValue = 'üü°';\n            const result = ValidationSelectors.getWarnings(existingComponentId)(\n                getStateForExistingComponent({\n                    warning: [\n                        {\n                            subId,\n                            value: warningValue,\n                        },\n                    ],\n                })\n            );\n\n            expect(result.length).toBe(1);\n            expect(result[0]).toEqual({\n                subId,\n                value: warningValue,\n            });\n        });\n\n        it('should not return warnings that have been cleared', () => {\n            const subId = 'something';\n            const result = ValidationSelectors.getErrors(existingComponentId)(\n                getStateForExistingComponent({\n                    warning: [\n                        {\n                            subId,\n                            value: '',\n                        },\n                    ],\n                })\n            );\n\n            expect(result.length).toBe(0);\n        });\n    });\n\n    describe('getIsDirty', () => {\n        it('should return an empty array if the state is empty', () => {\n            const result = ValidationSelectors.getIsDirty(existingComponentId)({\n                validation: {},\n            });\n\n            expect(result.length).toBe(0);\n        });\n\n        it('should return the registered dirty component', () => {\n            const subId = 'something';\n            const result = ValidationSelectors.getIsDirty(existingComponentId)(\n                getStateForExistingComponent({\n                    isDirty: [\n                        {\n                            subId,\n                            value: true,\n                        },\n                    ],\n                })\n            );\n\n            expect(result.length).toBe(1);\n            expect(result[0]).toEqual({\n                subId,\n                value: true,\n            });\n        });\n\n        it('should return the registered non-dirty component', () => {\n            const subId = 'something';\n            const result = ValidationSelectors.getIsDirty(existingComponentId)(\n                getStateForExistingComponent({\n                    isDirty: [\n                        {\n                            subId,\n                            value: false,\n                        },\n                    ],\n                })\n            );\n\n            expect(result.length).toBe(1);\n            expect(result[0]).toEqual({\n                subId,\n                value: false,\n            });\n        });\n    });\n\n    describe('getAnyError', () => {\n        it('should return an empty array if the state is empty', () => {\n            const result = ValidationSelectors.getAnyError([existingComponentId])({\n                validation: {},\n            });\n\n            expect(result.length).toBe(0);\n        });\n\n        it('should return only error states for the given ids', () => {\n            const anotherComponentId = 'üå∑';\n            const state = {\n                validation: {\n                    [existingComponentId]: getValidationState({\n                        error: [\n                            {\n                                subId: 'some-input',\n                                value: 'someerror',\n                            },\n                        ],\n                    }),\n                    [anotherComponentId]: getValidationState({\n                        error: [\n                            {\n                                subId: 'not-empty',\n                                value: 'hey this should not be empty',\n                            },\n                            {\n                                subId: 'thisvalidationsucceeded',\n                                value: '',\n                            },\n                        ],\n                    }),\n                },\n            };\n            const result = ValidationSelectors.getAnyError([existingComponentId, anotherComponentId])(state);\n\n            expect(result.length).toBe(2);\n            expect(result).toContain(state.validation[existingComponentId].error[0]);\n            expect(result).toContain(state.validation[anotherComponentId].error[0]);\n            expect(result).not.toContain(state.validation[anotherComponentId].error[1]);\n        });\n    });\n\n    describe('getAnyWarning', () => {\n        it('should return an empty array if the state is empty', () => {\n            const result = ValidationSelectors.getAnyWarning([existingComponentId])({\n                validation: {},\n            });\n\n            expect(result.length).toBe(0);\n        });\n\n        it('should return only error states for the given ids', () => {\n            const anotherComponentId = 'üå∑';\n            const state = {\n                validation: {\n                    [existingComponentId]: getValidationState({\n                        warning: [\n                            {\n                                subId: 'some-input',\n                                value: 'somewarning',\n                            },\n                        ],\n                    }),\n                    [anotherComponentId]: getValidationState({\n                        warning: [\n                            {\n                                subId: 'not-empty',\n                                value: 'be careful',\n                            },\n                            {\n                                subId: 'thisvalidationsucceeded',\n                                value: '',\n                            },\n                        ],\n                    }),\n                },\n            };\n            const result = ValidationSelectors.getAnyWarning([existingComponentId, anotherComponentId])(state);\n\n            expect(result.length).toBe(2);\n            expect(result).toContain(state.validation[existingComponentId].warning[0]);\n            expect(result).toContain(state.validation[anotherComponentId].warning[0]);\n            expect(result).not.toContain(state.validation[anotherComponentId].warning[1]);\n        });\n    });\n\n    describe('getAnyDirty', () => {\n        it('should return an empty array if the state is empty', () => {\n            const result = ValidationSelectors.getAnyDirty([existingComponentId])({\n                validation: {},\n            });\n\n            expect(result.length).toBe(0);\n        });\n\n        it('should return only dirty states for the given ids', () => {\n            const anotherComponentId = 'üå∑';\n            const state = {\n                validation: {\n                    [existingComponentId]: getValidationState({\n                        isDirty: [\n                            {\n                                subId: 'some-input',\n                                value: true,\n                            },\n                        ],\n                    }),\n                    [anotherComponentId]: getValidationState({\n                        isDirty: [\n                            {\n                                subId: 'not-empty',\n                                value: true,\n                            },\n                            {\n                                subId: 'thisisnotdirty',\n                                value: false,\n                            },\n                        ],\n                    }),\n                },\n            };\n            const result = ValidationSelectors.getAnyDirty([existingComponentId, anotherComponentId])(state);\n\n            expect(result.length).toBe(2);\n            expect(result).toContain(state.validation[existingComponentId].isDirty[0]);\n            expect(result).toContain(state.validation[anotherComponentId].isDirty[0]);\n            expect(result).not.toContain(state.validation[anotherComponentId].isDirty[1]);\n        });\n    });\n});\n"}}]);
//# sourceMappingURL=936.bundle.js.map