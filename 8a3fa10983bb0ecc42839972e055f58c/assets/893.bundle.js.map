{"version":3,"sources":["webpack:///./src/components/textarea/tests/TextArea.spec.tsx"],"names":[],"mappings":"6FAAA,OAAe","file":"assets/893.bundle.js","sourcesContent":["export default \"import {mount, ReactWrapper, shallow} from 'enzyme';\\r\\nimport * as React from 'react';\\r\\nimport {act} from 'react-dom/test-utils';\\r\\n\\r\\nimport {mountWithStore, shallowWithStore} from 'enzyme-redux';\\r\\nimport {getStoreMock, ReactVaporMockStore} from '../../../utils/tests/TestUtils';\\r\\nimport {ITextAreaProps, TextArea, TextAreaConnected} from '../TextArea';\\r\\nimport {TextAreaActions} from '../TextAreaActions';\\r\\n\\r\\ndescribe('TextArea', () => {\\r\\n    describe('<TextArea />', () => {\\r\\n        it('should render without errors', () => {\\r\\n            expect(() => {\\r\\n                shallow(<TextArea id=\\\"textarea-id\\\" />);\\r\\n            }).not.toThrow();\\r\\n        });\\r\\n    });\\r\\n\\r\\n    describe('<TextArea />', () => {\\r\\n        let hookWrapper: ReactWrapper<ITextAreaProps, any>;\\r\\n        let wrapper: ReactWrapper<ITextAreaProps, any>;\\r\\n\\r\\n        beforeEach(() => {\\r\\n            wrapper = mount(<TextArea id=\\\"textarea-id\\\" />, {attachTo: document.getElementById('App')});\\r\\n        });\\r\\n\\r\\n        afterEach(() => {\\r\\n            wrapper.detach();\\r\\n        });\\r\\n\\r\\n        it('should set textarea id when specified', () => {\\r\\n            expect(wrapper.prop('id')).toBe('textarea-id');\\r\\n        });\\r\\n\\r\\n        it('should set className when specified', () => {\\r\\n            const className = 'a-class';\\r\\n            expect(wrapper.hasClass(className)).toBe(false);\\r\\n\\r\\n            wrapper.setProps({className}).update();\\r\\n            expect(wrapper.find('textarea').hasClass(className)).toBe(true);\\r\\n        });\\r\\n\\r\\n        it('should set additionalAttributes when specified', () => {\\r\\n            expect(wrapper.prop('placeholder')).toBeUndefined();\\r\\n            wrapper.setProps({additionalAttributes: {placeholder: 'not null'}}).update();\\r\\n            expect(wrapper.find('textarea').prop('placeholder')).toBe('not null');\\r\\n        });\\r\\n\\r\\n        it('should set disabled prop when specified', () => {\\r\\n            expect(wrapper.prop('disabled')).toBeUndefined();\\r\\n            wrapper.setProps({disabled: true}).update();\\r\\n            expect(wrapper.find('textarea').prop('disabled')).toBe(true);\\r\\n        });\\r\\n\\r\\n        it('should set validate prop when specified', () => {\\r\\n            const validation = (value: string) => value !== '';\\r\\n\\r\\n            expect(wrapper.prop('validate')).toBeUndefined();\\r\\n            wrapper.setProps({validate: validation}).update();\\r\\n            expect(wrapper.prop('validate')).toBe(validation);\\r\\n        });\\r\\n\\r\\n        it('should set value prop when specified', () => {\\r\\n            expect(wrapper.prop('value')).toBeUndefined();\\r\\n            wrapper.setProps({value: 'non empty'}).update();\\r\\n            expect(wrapper.find('textarea').prop('value')).toBe('non empty');\\r\\n        });\\r\\n\\r\\n        it('should not throw if the onChange prop is not defined onChange', () => {\\r\\n            wrapper.setProps({onChange: undefined}).update();\\r\\n\\r\\n            expect(() => wrapper.find('textarea').simulate('change')).not.toThrow();\\r\\n        });\\r\\n\\r\\n        it('should not throw if the onChangeCallback prop is not defined onChange', () => {\\r\\n            wrapper.setProps({onChangeCallback: undefined});\\r\\n\\r\\n            expect(() => wrapper.find('textarea').simulate('change')).not.toThrow();\\r\\n        });\\r\\n\\r\\n        it('should call prop onChange on textarea change', () => {\\r\\n            const onChange = jasmine.createSpy('onChange');\\r\\n\\r\\n            wrapper.setProps({onChange}).update();\\r\\n            wrapper.find('textarea').simulate('change');\\r\\n\\r\\n            expect(onChange).toHaveBeenCalledTimes(1);\\r\\n        });\\r\\n\\r\\n        it('should call prop onChangeCallback on textarea change', () => {\\r\\n            const onChangeCallback = jasmine.createSpy('onChangeCallback');\\r\\n\\r\\n            wrapper.setProps({onChangeCallback}).update();\\r\\n            wrapper.find('textarea').simulate('change');\\r\\n\\r\\n            expect(onChangeCallback).toHaveBeenCalledTimes(1);\\r\\n        });\\r\\n\\r\\n        it('should contains validation message if changed value is invalid', () => {\\r\\n            const validation = (value: string) => value !== '';\\r\\n            const validationMessage = 'invalid value';\\r\\n            const invalidValue = '';\\r\\n\\r\\n            wrapper.setProps({validate: validation, validationMessage: validationMessage, value: invalidValue});\\r\\n            act(() => {\\r\\n                wrapper.update();\\r\\n            });\\r\\n            wrapper.setProps({value: invalidValue});\\r\\n            act(() => {\\r\\n                wrapper.update();\\r\\n            });\\r\\n\\r\\n            expect(wrapper.contains(validationMessage)).toBeTruthy();\\r\\n        });\\r\\n\\r\\n        it('should call prop validate on value change', () => {\\r\\n            const validate = jasmine.createSpy('validate');\\r\\n            hookWrapper = mount(<TextArea id=\\\"textarea-id\\\" validate={validate} />);\\r\\n\\r\\n            hookWrapper.find('textarea').simulate('change', {target: {value: 'new value'}});\\r\\n            act(() => {\\r\\n                hookWrapper.update();\\r\\n            });\\r\\n\\r\\n            expect(validate).toHaveBeenCalledTimes(1);\\r\\n        });\\r\\n\\r\\n        it('should call prop onMount on mount', () => {\\r\\n            const onMount = jasmine.createSpy('onMount');\\r\\n\\r\\n            hookWrapper = mount(<TextArea id=\\\"textarea-id\\\" onMount={onMount} />);\\r\\n\\r\\n            act(() => {\\r\\n                hookWrapper.update();\\r\\n            });\\r\\n\\r\\n            expect(onMount).toHaveBeenCalledTimes(1);\\r\\n        });\\r\\n\\r\\n        it('should call prop onUnmount on Unmount', () => {\\r\\n            const onUnmount = jasmine.createSpy('onUnmount');\\r\\n\\r\\n            hookWrapper = mount(<TextArea id=\\\"textarea-id\\\" onUnmount={onUnmount} />);\\r\\n\\r\\n            act(() => {\\r\\n                hookWrapper.unmount();\\r\\n            });\\r\\n\\r\\n            expect(onUnmount).toHaveBeenCalledTimes(1);\\r\\n\\r\\n            wrapper.setProps({onUnmount}).unmount();\\r\\n\\r\\n            expect(onUnmount).toHaveBeenCalledTimes(1);\\r\\n        });\\r\\n\\r\\n        describe('<TextAreaConnected />', () => {\\r\\n            let store: ReactVaporMockStore;\\r\\n            let textAreaProps: ITextAreaProps;\\r\\n\\r\\n            const mountComponentWithProps = (props: ITextAreaProps) =>\\r\\n                shallowWithStore(<TextAreaConnected {...props} />, store);\\r\\n\\r\\n            beforeEach(() => {\\r\\n                store = getStoreMock();\\r\\n                textAreaProps = {id: 'textarea-id'};\\r\\n            });\\r\\n\\r\\n            afterEach(() => {\\r\\n                store.clearActions();\\r\\n                wrapper.detach();\\r\\n            });\\r\\n\\r\\n            describe('dispatch props', () => {\\r\\n                it('should not throw when calling onMount with basic props', () => {\\r\\n                    expect(() =>\\r\\n                        mountComponentWithProps(textAreaProps)\\r\\n                            .find(TextArea)\\r\\n                            .prop('onMount')()\\r\\n                    ).not.toThrow();\\r\\n                });\\r\\n\\r\\n                it('should not throw when calling onUnmount', () => {\\r\\n                    expect(() =>\\r\\n                        mountComponentWithProps(textAreaProps)\\r\\n                            .find(TextArea)\\r\\n                            .prop('onUnmount')()\\r\\n                    ).not.toThrow();\\r\\n                });\\r\\n\\r\\n                it('should not throw when calling onChange', () => {\\r\\n                    expect(() =>\\r\\n                        mountComponentWithProps(textAreaProps)\\r\\n                            .find(TextArea)\\r\\n                            .prop('onChange')({target: {value: 'some value'}} as any)\\r\\n                    ).not.toThrow();\\r\\n                });\\r\\n            });\\r\\n\\r\\n            describe('onMount', () => {\\r\\n                it('should add a textArea in the store with default values', () => {\\r\\n                    const add = spyOn(TextAreaActions, 'add');\\r\\n\\r\\n                    hookWrapper = mountWithStore(<TextAreaConnected id={'textarea-id'} onMount={add} />, store);\\r\\n                    act(() => {\\r\\n                        hookWrapper.update();\\r\\n                    });\\r\\n\\r\\n                    expect(add).toHaveBeenCalledTimes(1);\\r\\n                });\\r\\n\\r\\n                it('should add a textArea in the store with the valueOnMount if there is one in the props', () => {\\r\\n                    const valueOnMount = 'non empty value';\\r\\n\\r\\n                    hookWrapper = mountWithStore(\\r\\n                        <TextAreaConnected {...textAreaProps} valueOnMount={valueOnMount} />,\\r\\n                        store\\r\\n                    );\\r\\n                    act(() => {\\r\\n                        hookWrapper.mount();\\r\\n                    });\\r\\n                    expect(store.getActions().find((action) => action.type === 'ADD_TEXTAREA')).toEqual(\\r\\n                        jasmine.objectContaining({\\r\\n                            payload: jasmine.objectContaining({id: textAreaProps.id, value: valueOnMount}),\\r\\n                        })\\r\\n                    );\\r\\n                });\\r\\n\\r\\n                it('should add a textArea in the store with the disabledOnMount value if there is one in the props', () => {\\r\\n                    const disabledOnMount = true;\\r\\n\\r\\n                    hookWrapper = mountWithStore(\\r\\n                        <TextAreaConnected {...textAreaProps} disabledOnMount={disabledOnMount} />,\\r\\n                        store\\r\\n                    );\\r\\n                    act(() => {\\r\\n                        hookWrapper.mount();\\r\\n                    });\\r\\n\\r\\n                    expect(store.getActions().find((action) => action.type === 'ADD_TEXTAREA')).toEqual(\\r\\n                        jasmine.objectContaining({\\r\\n                            payload: jasmine.objectContaining({id: textAreaProps.id, disabled: disabledOnMount}),\\r\\n                        })\\r\\n                    );\\r\\n                });\\r\\n            });\\r\\n\\r\\n            describe('onUnmount', () => {\\r\\n                it('should remove the textArea from the store', () => {\\r\\n                    store = getStoreMock();\\r\\n                    const component = mountWithStore(<TextAreaConnected {...textAreaProps} />, store);\\r\\n                    act(() => {\\r\\n                        component.unmount();\\r\\n                    });\\r\\n\\r\\n                    expect(store.getActions().find((action) => action.type === 'REMOVE_TEXTAREA')).toEqual(\\r\\n                        jasmine.objectContaining({payload: jasmine.objectContaining({id: textAreaProps.id})})\\r\\n                    );\\r\\n                });\\r\\n            });\\r\\n\\r\\n            describe('onChange', () => {\\r\\n                it('should change the value in the store to the new value', () => {\\r\\n                    store = getStoreMock();\\r\\n                    const component = mountWithStore(<TextAreaConnected {...textAreaProps} />, store);\\r\\n\\r\\n                    component.find('textarea').simulate('change', {target: {value: 'new value'}});\\r\\n                    act(() => {\\r\\n                        component.update();\\r\\n                    });\\r\\n\\r\\n                    expect(store.getActions().find((action) => action.type === 'CHANGE_VALUE_TEXTAREA')).toEqual(\\r\\n                        jasmine.objectContaining({\\r\\n                            payload: jasmine.objectContaining({id: textAreaProps.id, value: 'new value'}),\\r\\n                        })\\r\\n                    );\\r\\n                });\\r\\n            });\\r\\n        });\\r\\n    });\\r\\n});\\r\\n\""],"sourceRoot":""}