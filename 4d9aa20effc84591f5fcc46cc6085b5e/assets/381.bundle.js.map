{"version":3,"sources":["webpack:///./src/components/filterBox/tests/FilterBox.spec.tsx"],"names":[],"mappings":"6FAAA,OAAe","file":"assets/381.bundle.js","sourcesContent":["export default \"import {mount, ReactWrapper, shallow} from 'enzyme';\\r\\n// tslint:disable-next-line:no-unused-variable\\r\\nimport * as React from 'react';\\r\\nimport {FILTER_PLACEHOLDER, FilterBox, IFilterBoxProps} from '../FilterBox';\\r\\n\\r\\ndescribe('FilterBox', () => {\\r\\n    const id: string = 'filter-box';\\r\\n\\r\\n    describe('<FilterBox />', () => {\\r\\n        it('should render without errors', () => {\\r\\n            expect(() => {\\r\\n                shallow(<FilterBox id={id} />);\\r\\n            }).not.toThrow();\\r\\n        });\\r\\n    });\\r\\n\\r\\n    describe('<FilterBox />', () => {\\r\\n        let filterBox: ReactWrapper<IFilterBoxProps, any>;\\r\\n        let filterBoxInstance: FilterBox;\\r\\n\\r\\n        beforeEach(() => {\\r\\n            filterBox = mount(<FilterBox id={id} />, {attachTo: document.getElementById('App')});\\r\\n            filterBoxInstance = filterBox.instance() as FilterBox;\\r\\n        });\\r\\n\\r\\n        afterEach(() => {\\r\\n            filterBox.detach();\\r\\n        });\\r\\n\\r\\n        it('should call prop onRender on mounting if set', () => {\\r\\n            const renderSpy = jasmine.createSpy('onRender');\\r\\n\\r\\n            expect(() => filterBoxInstance.componentWillMount()).not.toThrow();\\r\\n\\r\\n            filterBox.setProps({id: id, onRender: renderSpy});\\r\\n            filterBox.unmount();\\r\\n            filterBox.mount();\\r\\n            expect(renderSpy.calls.count()).toBe(1);\\r\\n        });\\r\\n\\r\\n        it('should call prop onDestroy on unmounting if set', () => {\\r\\n            const destroySpy = jasmine.createSpy('onDestroy');\\r\\n\\r\\n            expect(() => filterBoxInstance.componentWillUnmount()).not.toThrow();\\r\\n\\r\\n            filterBox.setProps({id: id, onDestroy: destroySpy});\\r\\n            filterBox.mount();\\r\\n            filterBox.unmount();\\r\\n            expect(destroySpy.calls.count()).toBe(1);\\r\\n        });\\r\\n\\r\\n        it('should call prop onFilter when the filter input value has changed and prop is set', () => {\\r\\n            const filterSpy = jasmine.createSpy('onFilter');\\r\\n            const input = filterBox.find('input');\\r\\n\\r\\n            input.simulate('change');\\r\\n            expect(filterSpy.calls.count()).toBe(0);\\r\\n\\r\\n            filterBox.setProps({id: id, onFilter: filterSpy});\\r\\n            filterBox.mount();\\r\\n            input.simulate('change');\\r\\n            expect(filterSpy.calls.count()).toBe(1);\\r\\n        });\\r\\n\\r\\n        it('should call prop onFilterCallback when the filter input value has changed and prop is set', () => {\\r\\n            const onFilterCallbackSpy = jasmine.createSpy('onFilterCallback');\\r\\n            const input = filterBox.find('input');\\r\\n\\r\\n            input.simulate('change');\\r\\n            expect(onFilterCallbackSpy).not.toHaveBeenCalled();\\r\\n\\r\\n            filterBox.setProps({id: id, onFilterCallback: onFilterCallbackSpy});\\r\\n            filterBox.mount();\\r\\n            input.simulate('change');\\r\\n            expect(onFilterCallbackSpy).toHaveBeenCalledTimes(1);\\r\\n        });\\r\\n\\r\\n        it('should display the filterPlaceholder if set as a prop else, display the default one', () => {\\r\\n            const expectedPlaceholder = 'new placeholder';\\r\\n\\r\\n            expect(filterBox.html()).toContain(FILTER_PLACEHOLDER);\\r\\n\\r\\n            filterBox.setProps({id: id, filterPlaceholder: expectedPlaceholder});\\r\\n            filterBox.mount();\\r\\n            expect(filterBox.html()).not.toContain(FILTER_PLACEHOLDER);\\r\\n            expect(filterBox.html()).toContain(expectedPlaceholder);\\r\\n        });\\r\\n\\r\\n        it('should toggle the hidden class of the clear icon if there is a value or not in the filter input', () => {\\r\\n            expect(\\r\\n                filterBox\\r\\n                    .find('span')\\r\\n                    .first()\\r\\n                    .hasClass('hidden')\\r\\n            ).toBe(true);\\r\\n\\r\\n            filterBoxInstance.filterInput.value = 'something';\\r\\n            filterBox.find('input').simulate('change');\\r\\n            filterBox.mount().update();\\r\\n            expect(\\r\\n                filterBox\\r\\n                    .find('span')\\r\\n                    .first()\\r\\n                    .hasClass('hidden')\\r\\n            ).toBe(false);\\r\\n\\r\\n            filterBoxInstance.filterInput.value = '';\\r\\n            filterBox.find('input').simulate('change');\\r\\n            filterBox.mount().update();\\r\\n            expect(\\r\\n                filterBox\\r\\n                    .find('span')\\r\\n                    .first()\\r\\n                    .hasClass('hidden')\\r\\n            ).toBe(true);\\r\\n        });\\r\\n\\r\\n        it('should remove the hidden class of the clear icon if there is a value in the input without a change event', () => {\\r\\n            expect(\\r\\n                filterBox\\r\\n                    .find('span')\\r\\n                    .first()\\r\\n                    .hasClass('hidden')\\r\\n            ).toBe(true);\\r\\n\\r\\n            (filterBox.instance() as FilterBox).filterInput.value = 'non empty';\\r\\n            filterBox.mount().update();\\r\\n\\r\\n            expect(\\r\\n                filterBox\\r\\n                    .find('span')\\r\\n                    .first()\\r\\n                    .hasClass('hidden')\\r\\n            ).toBe(false);\\r\\n        });\\r\\n\\r\\n        it('should leave the hidden class of the clear icon if there is an empty value in the input without a change event', () => {\\r\\n            filterBoxInstance.filterInput.value = '';\\r\\n            filterBox.update();\\r\\n\\r\\n            expect(\\r\\n                filterBox\\r\\n                    .find('span')\\r\\n                    .first()\\r\\n                    .hasClass('hidden')\\r\\n            ).toBe(true);\\r\\n        });\\r\\n\\r\\n        it('should clear the filter input when clicking the clear icon', () => {\\r\\n            const clearIcon = filterBox.find('span').first();\\r\\n\\r\\n            filterBoxInstance.filterInput.value = 'something';\\r\\n\\r\\n            clearIcon.simulate('click');\\r\\n            expect(filterBoxInstance.filterInput.value).toBe('');\\r\\n        });\\r\\n\\r\\n        it('should focus the filter box input when clicking the clear icon', () => {\\r\\n            const clearIcon = filterBox.find('span').first();\\r\\n\\r\\n            expect(filterBoxInstance.filterInput).not.toBe(document.activeElement as HTMLInputElement);\\r\\n\\r\\n            clearIcon.simulate('click');\\r\\n            expect(filterBoxInstance.filterInput).toBe(document.activeElement as HTMLInputElement);\\r\\n        });\\r\\n\\r\\n        it('should set container class when the container class is specified', () => {\\r\\n            const containerClass = 'mod-small';\\r\\n            const containerClasses = [containerClass];\\r\\n            expect(\\r\\n                filterBox\\r\\n                    .find('.filter-container')\\r\\n                    .first()\\r\\n                    .hasClass(containerClass)\\r\\n            ).toBe(false);\\r\\n\\r\\n            filterBox.setProps({id: id, containerClasses}).update();\\r\\n            expect(\\r\\n                filterBox\\r\\n                    .find('.filter-container')\\r\\n                    .first()\\r\\n                    .hasClass(containerClass)\\r\\n            ).toBe(true);\\r\\n        });\\r\\n\\r\\n        it('should call onBlur when the input loose focus', () => {\\r\\n            const onBlur = jasmine.createSpy('onBlur');\\r\\n            filterBox.setProps({onBlur});\\r\\n\\r\\n            const element = filterBox.find('.filter-box');\\r\\n            element.simulate('focus');\\r\\n            element.simulate('blur');\\r\\n\\r\\n            expect(onBlur).toHaveBeenCalled();\\r\\n        });\\r\\n\\r\\n        it('should call onKeyDown when the input get a key down event', () => {\\r\\n            const onKeyDown = jasmine.createSpy('onKeyDown');\\r\\n            filterBox.setProps({onKeyDown});\\r\\n\\r\\n            const element = filterBox.find('.filter-box');\\r\\n            element.simulate('keydown');\\r\\n\\r\\n            expect(onKeyDown).toHaveBeenCalled();\\r\\n        });\\r\\n\\r\\n        it('should call onKeyUp when the input get a key up event', () => {\\r\\n            const onKeyUp = jasmine.createSpy('onKeyUp');\\r\\n            filterBox.setProps({onKeyUp});\\r\\n\\r\\n            const element = filterBox.find('.filter-box');\\r\\n            element.simulate('keyup');\\r\\n\\r\\n            expect(onKeyUp).toHaveBeenCalled();\\r\\n        });\\r\\n\\r\\n        it('should call placeCursorAtEndOfInputValue when a focus event is triggered on the filter box', () => {\\r\\n            const placeCursorAtEndOfInputValueSpy = spyOn(FilterBox.prototype, 'placeCursorAtEndOfInputValue');\\r\\n\\r\\n            const element = filterBox.find('.filter-box');\\r\\n            element.simulate('focus');\\r\\n\\r\\n            expect(placeCursorAtEndOfInputValueSpy).toHaveBeenCalledTimes(1);\\r\\n        });\\r\\n\\r\\n        describe('withTitleOnInput', () => {\\r\\n            beforeEach(() => {\\r\\n                filterBox = mount(<FilterBox id={id} withTitleOnInput={true} />, {\\r\\n                    attachTo: document.getElementById('App'),\\r\\n                });\\r\\n            });\\r\\n\\r\\n            it('should not have a title on the input container if the input has a value in it', () => {\\r\\n                expect(filterBox.find('.filter-container').prop('title')).toBeUndefined();\\r\\n            });\\r\\n\\r\\n            it('should have a title on the input container if the input has a value in it', () => {\\r\\n                (filterBox.instance() as FilterBox).filterInput.value = 'test';\\r\\n                filterBox.mount().update();\\r\\n\\r\\n                expect((filterBox.find('.filter-container').instance() as any).title).toBe('test');\\r\\n            });\\r\\n        });\\r\\n\\r\\n        describe('maxWidth', () => {\\r\\n            it('should set a max width in px on the filter container and the filter input when max width is set', () => {\\r\\n                filterBox = mount(<FilterBox id={id} maxWidth={130} />, {attachTo: document.getElementById('App')});\\r\\n\\r\\n                expect(filterBox.find('.filter-container').prop('style')).toEqual({maxWidth: '130px'});\\r\\n                expect(filterBox.find('.filter-box').prop('style')).toEqual({maxWidth: '130px'});\\r\\n            });\\r\\n        });\\r\\n\\r\\n        describe('truncate', () => {\\r\\n            it('should not add the \\\"truncate\\\" class to the filter input if it is not set', () => {\\r\\n                filterBox = mount(<FilterBox id={id} />, {attachTo: document.getElementById('App')});\\r\\n\\r\\n                expect(filterBox.find('.filter-box').hasClass('truncate')).toBe(false);\\r\\n            });\\r\\n\\r\\n            it('should add the \\\"truncate\\\" class to the filter input if it is true', () => {\\r\\n                filterBox = mount(<FilterBox id={id} truncate={true} />, {attachTo: document.getElementById('App')});\\r\\n\\r\\n                expect(filterBox.find('.filter-box').hasClass('truncate')).toBe(true);\\r\\n            });\\r\\n        });\\r\\n    });\\r\\n});\\r\\n\""],"sourceRoot":""}