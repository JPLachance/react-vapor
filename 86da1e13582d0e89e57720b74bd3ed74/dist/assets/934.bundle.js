(window.webpackJsonp=window.webpackJsonp||[]).push([[934],{2034:function(t,n,o){"use strict";o.r(n),n.default="import {shallowWithStore} from 'enzyme-redux';\nimport * as React from 'react';\nimport * as _ from 'underscore';\nimport {getStoreMock} from '../../../../utils/tests/TestUtils';\nimport {Button, IButtonProps} from '../../../button';\nimport {IWithDirtySaveButtonHOCProps, withDirtySaveButtonHOC} from '../WithDirtySaveButtonHOC';\n\ndescribe('WithDirtySaveButtonHOC', () => {\n    const ButtonWithHOC = withDirtySaveButtonHOC(Button);\n    const buttonValidationId = 'someid';\n\n    let store: ReturnType<typeof getStoreMock>;\n\n    const BUTTON_PROPS: IButtonProps & IWithDirtySaveButtonHOCProps = {\n        enabled: true,\n        validationIds: [buttonValidationId],\n    };\n\n    beforeEach(() => {\n        store = getStoreMock({\n            validation: {},\n        });\n    });\n\n    afterEach(() => {\n        store.clearActions();\n    });\n\n    it('should render without error', () => {\n        expect(() => shallowWithStore(<ButtonWithHOC {...BUTTON_PROPS} />, store)).not.toThrow();\n    });\n\n    it('should mount and unmount/detach without error', () => {\n        expect(() => {\n            const buttonWrapper = shallowWithStore(<ButtonWithHOC {...BUTTON_PROPS} />, store);\n            buttonWrapper.unmount();\n        }).not.toThrow();\n    });\n\n    describe('<ButtonWithHOC />', () => {\n        const storeWithErrorsAndDirty: ReturnType<typeof getStoreMock> = getStoreMock({\n            validation: {\n                [buttonValidationId]: {\n                    error: [{validationType: 'something', value: 'bad'}],\n                    warning: [],\n                    isDirty: [{validationType: 'something', value: true}],\n                },\n            },\n        });\n        const storeWithWarningsAndDirty: ReturnType<typeof getStoreMock> = getStoreMock({\n            validation: {\n                [buttonValidationId]: {\n                    error: [],\n                    warning: [{validationType: 'something', value: 'slightly bad'}],\n                    isDirty: [{validationType: 'something', value: true}],\n                },\n            },\n        });\n        const storeWithDirty = getStoreMock({\n            validation: {\n                [buttonValidationId]: {\n                    error: [],\n                    warning: [],\n                    isDirty: [{validationType: 'dirty', value: true}],\n                },\n            },\n        });\n        const shallowButton = (props: Partial<typeof BUTTON_PROPS>, storeToUse: ReturnType<typeof getStoreMock>) =>\n            shallowWithStore<typeof ButtonWithHOC>(<ButtonWithHOC {...BUTTON_PROPS} {...props} />, storeToUse).dive();\n\n        beforeEach(() => {\n            storeWithErrorsAndDirty.clearActions();\n            storeWithWarningsAndDirty.clearActions();\n            storeWithDirty.clearActions();\n        });\n\n        describe('button enabled prop', () => {\n            it('should be enabled when the component is dirty without errors', () => {\n                const buttonWrapper = shallowButton({}, storeWithDirty);\n\n                const enabled = buttonWrapper.find(Button).prop('enabled');\n\n                expect(enabled).toBe(true);\n            });\n\n            it('should be disabled when the enabled prop is passed down', () => {\n                const buttonWrapper = shallowButton({enabled: false}, storeWithDirty);\n\n                const enabled = buttonWrapper.find(Button).prop('enabled');\n\n                expect(enabled).toBe(false);\n            });\n\n            it('should be disabled when no component is dirty', () => {\n                const buttonWrapper = shallowButton({}, getStoreMock());\n\n                const enabled = buttonWrapper.find(Button).prop('enabled');\n\n                expect(enabled).toBe(false);\n            });\n\n            it('should be enabled when no component is dirty but the HOC is configured to skip the dirty check', () => {\n                const buttonWrapper = shallowButton({skipDirty: true}, getStoreMock());\n\n                const enabled = buttonWrapper.find(Button).prop('enabled');\n\n                expect(enabled).toBe(true);\n            });\n\n            it('should be enabled when the component is dirty with warnings', () => {\n                const buttonWrapper = shallowButton({}, storeWithWarningsAndDirty);\n\n                const enabled = buttonWrapper.find(Button).prop('enabled');\n\n                expect(enabled).toBe(true);\n            });\n\n            it('should be disabled when there are errors', () => {\n                const buttonWrapper = shallowButton({}, storeWithErrorsAndDirty);\n\n                const enabled = buttonWrapper.find(Button).prop('enabled');\n\n                expect(enabled).toBe(false);\n            });\n        });\n\n        describe('button tooltip prop', () => {\n            it('should change the tooltip to the error message formatter', () => {\n                const message = 'this is bad';\n                const buttonWrapper = shallowButton(\n                    {\n                        errorMessage: () => message,\n                    },\n                    storeWithErrorsAndDirty\n                );\n\n                const tooltip = buttonWrapper.find(Button).prop('tooltip');\n\n                expect(tooltip).toEqual(message);\n            });\n\n            it('should change the tooltip to the warning message formatter', () => {\n                const message = 'this is slightly bad';\n                const buttonWrapper = shallowButton(\n                    {\n                        warningMessage: () => message,\n                    },\n                    storeWithWarningsAndDirty\n                );\n\n                const tooltip = buttonWrapper.find(Button).prop('tooltip');\n\n                expect(tooltip).toEqual(message);\n            });\n\n            it('should change the tooltip to the dirty message formatter', () => {\n                const message = 'you must change stuff';\n                const buttonWrapper = shallowButton(\n                    {\n                        dirtyMessage: () => message,\n                    },\n                    getStoreMock()\n                );\n\n                const tooltip = buttonWrapper.find(Button).prop('tooltip');\n\n                expect(tooltip).toEqual(message);\n            });\n\n            it('should not change the tooltip when there is a warning but the component is not dirty', () => {\n                const storeWithOnlyWarning = getStoreMock({\n                    validation: {\n                        [buttonValidationId]: {\n                            error: [],\n                            warning: [{validationType: 'something', value: 'slightly bad'}],\n                            isDirty: [],\n                        },\n                    },\n                });\n                const message = 'this is slightly bad';\n                const buttonWrapper = shallowButton(\n                    {\n                        warningMessage: () => message,\n                    },\n                    storeWithOnlyWarning\n                );\n\n                const tooltip = buttonWrapper.find(Button).prop('tooltip');\n\n                expect(tooltip).not.toEqual(message);\n            });\n        });\n    });\n});\n"}}]);
//# sourceMappingURL=934.bundle.js.map