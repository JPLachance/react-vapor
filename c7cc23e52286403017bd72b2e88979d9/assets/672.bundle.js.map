{"version":3,"sources":["webpack:///./src/components/select/hoc/tests/MultiSelectWithPredicate.spec.tsx"],"names":[],"mappings":"6FAAA,OAAe","file":"assets/672.bundle.js","sourcesContent":["export default \"import {mount, ReactWrapper, ShallowWrapper} from 'enzyme';\\r\\nimport {shallowWithStore} from 'enzyme-redux';\\r\\nimport * as React from 'react';\\r\\nimport {act} from 'react-dom/test-utils';\\r\\nimport {Provider} from 'react-redux';\\r\\nimport {Store} from 'redux';\\r\\nimport * as _ from 'underscore';\\r\\n\\r\\nimport {withServerSideProcessing} from '../../../../hoc/withServerSideProcessing/withServerSideProcessing';\\r\\nimport {IReactVaporState} from '../../../../ReactVapor';\\r\\nimport {clearState} from '../../../../utils/ReduxUtils';\\r\\nimport {TestUtils} from '../../../../utils/tests/TestUtils';\\r\\nimport {UUID} from '../../../../utils/UUID';\\r\\nimport {DraggableSelectedOption} from '../../../dropdownSearch/MultiSelectDropdownSearch/DraggableSelectedOption';\\r\\nimport {selectFlatSelect} from '../../../flatSelect/FlatSelectActions';\\r\\nimport {IFlatSelectOptionProps} from '../../../flatSelect/FlatSelectOption';\\r\\nimport {IItemBoxProps} from '../../../itemBox/ItemBox';\\r\\nimport {reorderListBoxOption, unselectListBoxOption} from '../../../listBox/ListBoxActions';\\r\\nimport {IMultiSelectOwnProps, IMultiSelectProps, MultiSelectConnected} from '../../MultiSelectConnected';\\r\\nimport {toggleSelect} from '../../SelectActions';\\r\\nimport {SelectConnected} from '../../SelectConnected';\\r\\nimport {MultiSelectWithPredicate} from '../SelectComponents';\\r\\nimport {ISelectWithPredicateProps, selectWithPredicate} from '../SelectWithPredicate';\\r\\n\\r\\ndescribe('Select', () => {\\r\\n    describe('<MultiSelectWithPredicate />', () => {\\r\\n        let wrapper: ReactWrapper<any, any>;\\r\\n        let multiSelect: ReactWrapper<IMultiSelectProps, void>;\\r\\n        let store: Store<IReactVaporState>;\\r\\n\\r\\n        const id: string = 'multi-select-with-predicate';\\r\\n        const defaultFlatSelectOptions: IFlatSelectOptionProps[] = [\\r\\n            {id: UUID.generate(), option: {content: 'All'}, selected: true},\\r\\n            {id: UUID.generate(), option: {content: 'None'}},\\r\\n        ];\\r\\n        const matchPredicate = (predicate: string, item: IItemBoxProps) => {\\r\\n            return predicate === defaultFlatSelectOptions[0].id;\\r\\n        };\\r\\n\\r\\n        const basicProps: ISelectWithPredicateProps & IMultiSelectOwnProps = {\\r\\n            id,\\r\\n            items: [],\\r\\n            options: defaultFlatSelectOptions,\\r\\n            matchPredicate,\\r\\n        };\\r\\n\\r\\n        const mountMultiSelect = (props?: Partial<ISelectWithPredicateProps & IMultiSelectOwnProps>) => {\\r\\n            wrapper = mount(\\r\\n                <Provider store={store}>\\r\\n                    <MultiSelectWithPredicate {...basicProps} {...props} />\\r\\n                </Provider>,\\r\\n                {attachTo: document.getElementById('App')}\\r\\n            );\\r\\n            multiSelect = wrapper.find(SelectConnected).first();\\r\\n        };\\r\\n\\r\\n        beforeEach(() => {\\r\\n            store = TestUtils.buildStore();\\r\\n        });\\r\\n\\r\\n        afterEach(() => {\\r\\n            store.dispatch(clearState());\\r\\n            if (wrapper && wrapper.exists()) {\\r\\n                wrapper.detach();\\r\\n            }\\r\\n        });\\r\\n\\r\\n        describe('mount and unmount', () => {\\r\\n            it('should not throw on mount', () => {\\r\\n                expect(() => mountMultiSelect()).not.toThrow();\\r\\n            });\\r\\n\\r\\n            it('should not throw on unmount', () => {\\r\\n                mountMultiSelect();\\r\\n                expect(() => wrapper.unmount()).not.toThrow();\\r\\n            });\\r\\n\\r\\n            it('should add the list box to the state when mounted', () => {\\r\\n                expect(store.getState().selects.length).toBe(0);\\r\\n\\r\\n                mountMultiSelect();\\r\\n\\r\\n                expect(store.getState().selects.length).toBe(1);\\r\\n            });\\r\\n\\r\\n            it('should remove the list box from the state when the component unmount', () => {\\r\\n                mountMultiSelect();\\r\\n\\r\\n                expect(store.getState().selects.length).toBe(1);\\r\\n                wrapper.unmount();\\r\\n\\r\\n                expect(store.getState().selects.length).toBe(0);\\r\\n            });\\r\\n        });\\r\\n\\r\\n        it('should hide items when they do not match the predicates', () => {\\r\\n            const items = [{value: 'a'}, {value: 'b', selected: true}, {value: 'c', selected: true}];\\r\\n\\r\\n            mountMultiSelect({items});\\r\\n            store.dispatch(toggleSelect(id, true));\\r\\n            store.dispatch(selectFlatSelect(id, defaultFlatSelectOptions[1].id));\\r\\n            wrapper.update();\\r\\n            multiSelect = wrapper.find(SelectConnected);\\r\\n\\r\\n            expect(multiSelect.props().items.length).toBe(items.length);\\r\\n            multiSelect\\r\\n                .find(SelectConnected)\\r\\n                .props()\\r\\n                .items.every((item: IItemBoxProps) => expect(item.hidden).toBe(true));\\r\\n        });\\r\\n\\r\\n        it('should not show items that are already hidden', () => {\\r\\n            const items = [\\r\\n                {value: 'a', hidden: true},\\r\\n                {value: 'b', selected: true},\\r\\n                {value: 'c', selected: true},\\r\\n            ];\\r\\n\\r\\n            mountMultiSelect({items});\\r\\n            store.dispatch(toggleSelect(id, true));\\r\\n            store.dispatch(selectFlatSelect(id, defaultFlatSelectOptions[0].id));\\r\\n            wrapper.update();\\r\\n            multiSelect = wrapper.find(SelectConnected);\\r\\n\\r\\n            expect(multiSelect.props().items.length).toBe(items.length);\\r\\n            expect(multiSelect.find(SelectConnected).props().items[0].hidden).toBe(true);\\r\\n            expect(multiSelect.find(SelectConnected).props().items[1].hidden).toBeUndefined();\\r\\n            expect(multiSelect.find(SelectConnected).props().items[2].hidden).toBeUndefined();\\r\\n        });\\r\\n\\r\\n        describe('Sortable', () => {\\r\\n            it('should be possible to reorder items', () => {\\r\\n                const spy = spyOn(store, 'dispatch').and.callThrough();\\r\\n                const items = [\\r\\n                    {value: 'a', hidden: true},\\r\\n                    {value: 'b', selected: true},\\r\\n                    {value: 'c', selected: true},\\r\\n                ];\\r\\n\\r\\n                mountMultiSelect({items, sortable: true});\\r\\n\\r\\n                // Move b from 0 to 1\\r\\n                multiSelect\\r\\n                    .find(DraggableSelectedOption)\\r\\n                    .first()\\r\\n                    .prop('move')(0, 1);\\r\\n                expect(spy).toHaveBeenCalledWith(reorderListBoxOption(id, [items[2].value, items[1].value]));\\r\\n            });\\r\\n\\r\\n            it('should be possible to delete an item', () => {\\r\\n                const spy = spyOn(store, 'dispatch').and.callThrough();\\r\\n                const items = [\\r\\n                    {value: 'a', hidden: true},\\r\\n                    {value: 'b', selected: true},\\r\\n                    {value: 'c', selected: true},\\r\\n                ];\\r\\n\\r\\n                mountMultiSelect({items, sortable: true});\\r\\n\\r\\n                // Move b from 0 to 1\\r\\n                multiSelect\\r\\n                    .find(DraggableSelectedOption)\\r\\n                    .first()\\r\\n                    .prop('onRemoveClick')();\\r\\n                expect(spy).toHaveBeenCalledWith(unselectListBoxOption(id, items[1].value));\\r\\n            });\\r\\n        });\\r\\n\\r\\n        describe('when predicates are processed on the server side', () => {\\r\\n            const ServerSideMultiSelectWithPredicates = _.compose(\\r\\n                withServerSideProcessing,\\r\\n                selectWithPredicate\\r\\n            )(MultiSelectConnected);\\r\\n\\r\\n            const items = [\\r\\n                {value: 'a', hidden: true},\\r\\n                {value: 'b', selected: true},\\r\\n                {value: 'c', selected: true},\\r\\n            ];\\r\\n\\r\\n            it('should not filter the items based on any predicate because it is done on the server', () => {\\r\\n                const component: ShallowWrapper<ISelectWithPredicateProps> = shallowWithStore(\\r\\n                    <ServerSideMultiSelectWithPredicates\\r\\n                        {...basicProps}\\r\\n                        items={items}\\r\\n                        predicate={basicProps.options[1].id}\\r\\n                    />,\\r\\n                    store\\r\\n                )\\r\\n                    .dive()\\r\\n                    .dive();\\r\\n                expect(component.props().items).toEqual(items);\\r\\n            });\\r\\n\\r\\n            it('should trigger the onUpdate prop when the selected predicate changes', () => {\\r\\n                const onUpdateSpy = jasmine.createSpy('onUpdate');\\r\\n\\r\\n                wrapper = mount(\\r\\n                    <Provider store={store}>\\r\\n                        <ServerSideMultiSelectWithPredicates {...basicProps} onUpdate={onUpdateSpy} />\\r\\n                    </Provider>,\\r\\n                    {attachTo: document.getElementById('App')}\\r\\n                );\\r\\n\\r\\n                expect(onUpdateSpy).toHaveBeenCalledTimes(1);\\r\\n\\r\\n                store.dispatch(toggleSelect(id, true));\\r\\n                act(() => {\\r\\n                    store.dispatch(selectFlatSelect(id, defaultFlatSelectOptions[1].id));\\r\\n                });\\r\\n\\r\\n                expect(onUpdateSpy).toHaveBeenCalledTimes(2);\\r\\n            });\\r\\n        });\\r\\n    });\\r\\n});\\r\\n\""],"sourceRoot":""}